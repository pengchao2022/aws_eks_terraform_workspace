name: Terraform Multi-Environment Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy

env:
  AWS_REGION: us-east-1
  TF_STATE_BUCKET: "terraformstatefile090909"
  TF_STATE_KEY_PREFIX: "env"
  DYNAMODB_LOCK_TABLE: "terraform-locks"

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"
        # 禁用自动设置 TF_WORKSPACE
        terraform_wrapper: false

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Set environment variables
      run: |
        # 设置工作区相关的环境变量
        ENVIRONMENT="${{ github.event.inputs.environment }}"
        TF_STATE_KEY="$TF_STATE_KEY_PREFIX:/$ENVIRONMENT/eks-python-cluster/terraform.tfstate"
        echo "TF_WORKSPACE=$ENVIRONMENT" >> $GITHUB_ENV
        echo "TF_STATE_KEY=$TF_STATE_KEY" >> $GITHUB_ENV
        echo "Using workspace: $ENVIRONMENT"
        echo "State key: $TF_STATE_KEY"

    - name: Extract DynamoDB table name from backend config
      id: get-dynamodb-table
      run: |
        # 从 backend.tf 或 terraform 配置中提取 DynamoDB 表名
        if [ -f "backend.tf" ]; then
          TABLE_NAME=$(grep "dynamodb_table" backend.tf | grep -oP 'dynamodb_table\s*=\s*"\K[^"]+' || echo "$DYNAMODB_LOCK_TABLE")
        elif [ -f "*.tf" ]; then
          TABLE_NAME=$(grep -r "dynamodb_table" *.tf | head -1 | grep -oP 'dynamodb_table\s*=\s*"\K[^"]+' || echo "$DYNAMODB_LOCK_TABLE")
        else
          TABLE_NAME="$DYNAMODB_LOCK_TABLE"
        fi
        echo "table_name=${TABLE_NAME}" >> $GITHUB_OUTPUT
        echo "Using DynamoDB table: $TABLE_NAME"

    - name: Check for existing DynamoDB locks
      id: check-dynamodb-lock
      run: |
        LOCK_KEY="$TF_STATE_KEY-md5"
        echo "Checking for DynamoDB lock with key: $LOCK_KEY"
        
        # 检查 DynamoDB 中是否有锁
        LOCK_EXISTS=$(aws dynamodb get-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
          --query 'Item' \
          --output text 2>/dev/null || echo "false")
        
        if [ "$LOCK_EXISTS" != "false" ] && [ ! -z "$LOCK_EXISTS" ]; then
          echo "lock_exists=true" >> $GITHUB_OUTPUT
          LOCK_INFO=$(aws dynamodb get-item \
            --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
            --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
            --query 'Item' \
            --output json)
          echo "lock_info=$(echo $LOCK_INFO | jq -c .)" >> $GITHUB_OUTPUT
          echo "⚠️  Existing DynamoDB lock detected for key: $LOCK_KEY"
        else
          echo "lock_exists=false" >> $GITHUB_OUTPUT
          echo "✅ No existing DynamoDB locks found"
        fi

    - name: Cleanup stale DynamoDB lock (if exists)
      if: steps.check-dynamodb-lock.outputs.lock_exists == 'true'
      run: |
        LOCK_KEY="$TF_STATE_KEY-md5"
        echo "🔄 Cleaning up stale DynamoDB lock: $LOCK_KEY"
        
        # 删除 DynamoDB 中的锁
        aws dynamodb delete-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
          --return-consumed-capacity TOTAL
        
        echo "✅ DynamoDB lock cleaned up successfully"

    - name: Terraform Init
      run: terraform init -input=false -reconfigure

    - name: Setup Terraform Workspace
      run: |
        # 先列出所有工作区查看当前状态
        echo "Available workspaces:"
        terraform workspace list
        
        # 检查工作区是否已存在
        if terraform workspace list | grep -q " $TF_WORKSPACE$"; then
          echo "Workspace '$TF_WORKSPACE' already exists, selecting it..."
          terraform workspace select $TF_WORKSPACE
        else
          echo "Creating new workspace: $TF_WORKSPACE"
          terraform workspace new $TF_WORKSPACE
        fi
        echo "Current workspace: $(terraform workspace show)"

    - name: Validate tfvars File Exists
      run: |
        if [ ! -f "$TF_WORKSPACE.tfvars" ]; then
          echo "Error: $TF_WORKSPACE.tfvars file not found!"
          exit 1
        fi
        echo "Using tfvars file: $TF_WORKSPACE.tfvars"

    - name: Check for existing Terraform state locks
      id: check-state-lock
      run: |
        # 检查 Terraform 状态中是否有锁
        STATE_OUTPUT=$(terraform state pull 2>/dev/null || echo "{}")
        if echo "$STATE_OUTPUT" | grep -q "lock-info"; then
          echo "lock_exists=true" >> $GITHUB_OUTPUT
          LOCK_ID=$(echo "$STATE_OUTPUT" | jq -r '.["lock-info"].ID // empty' || echo "")
          echo "lock_id=$LOCK_ID" >> $GITHUB_OUTPUT
          echo "⚠️  Existing state lock detected: $LOCK_ID"
        else
          echo "lock_exists=false" >> $GITHUB_OUTPUT
          echo "✅ No existing state locks found"
        fi

    - name: Cleanup stale Terraform state lock (if exists)
      if: steps.check-state-lock.outputs.lock_exists == 'true'
      run: |
        echo "🔄 Cleaning up stale Terraform state lock: ${{ steps.check-state-lock.outputs.lock_id }}"
        terraform force-unlock -force ${{ steps.check-state-lock.outputs.lock_id }} || echo "State lock cleanup attempted"

    - name: Terraform Plan
      if: github.event.inputs.action == 'plan'
      run: |
        terraform plan \
          -var-file=$TF_WORKSPACE.tfvars \
          -out=tfplan

    - name: Terraform Apply
      if: github.event.inputs.action == 'apply'
      run: |
        terraform apply \
          -var-file=$TF_WORKSPACE.tfvars \
          -auto-approve

    - name: Terraform Destroy Plan
      if: github.event.inputs.action == 'destroy'
      run: |
        terraform plan -destroy \
          -var-file=$TF_WORKSPACE.tfvars \
          -out=destroy-plan
        echo "Destroy plan generated. Review before proceeding."

    - name: Terraform Destroy
      if: github.event.inputs.action == 'destroy'
      run: |
        terraform destroy \
          -var-file=$TF_WORKSPACE.tfvars \
          -auto-approve
      env:
        TF_CONFIRM_DESTROY: 1

    - name: Update Kubeconfig
      if: github.event.inputs.action == 'apply'
      run: |
        CLUSTER_NAME=$(grep 'cluster_name' $TF_WORKSPACE.tfvars | awk -F'=' '{print $2}' | tr -d ' "')
        aws eks update-kubeconfig \
          --region $AWS_REGION \
          --name $CLUSTER_NAME

    - name: Output Cluster Info
      if: github.event.inputs.action == 'apply'
      run: |
        terraform output -json > outputs.json
        echo "=== EKS Cluster Information ==="
        echo "Cluster Endpoint: $(terraform output -raw cluster_endpoint)"
        echo "Cluster Name: $(terraform output -raw cluster_name)"
        echo "Cluster Region: $AWS_REGION"

    - name: Destroy Completion Message
      if: github.event.inputs.action == 'destroy'
      run: |
        echo "✅ Terraform destroy completed successfully"
        echo "All resources in environment '$TF_WORKSPACE' have been destroyed"

    - name: Cleanup DynamoDB lock on completion
      if: always()
      run: |
        echo "🧹 Final DynamoDB lock cleanup..."
        LOCK_KEY="$TF_STATE_KEY-md5"
        
        # 检查并清理 DynamoDB 锁
        LOCK_EXISTS=$(aws dynamodb get-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
          --query 'Item' \
          --output text 2>/dev/null || echo "false")
        
        if [ "$LOCK_EXISTS" != "false" ] && [ ! -z "$LOCK_EXISTS" ]; then
          echo "Removing residual DynamoDB lock: $LOCK_KEY"
          aws dynamodb delete-item \
            --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
            --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}"
          echo "✅ Residual DynamoDB lock cleaned up"
        else
          echo "✅ No residual DynamoDB locks found"
        fi

    - name: Cleanup Terraform state lock on completion
      if: always()
      run: |
        echo "🧹 Final Terraform state lock cleanup..."
        # 尝试清理任何可能残留的状态锁
        STATE_OUTPUT=$(terraform state pull 2>/dev/null || echo "{}")
        LOCK_INFO=$(echo "$STATE_OUTPUT" | jq -r '.["lock-info"].ID // empty' || echo "")
        if [ ! -z "$LOCK_INFO" ]; then
          echo "Removing residual state lock: $LOCK_INFO"
          terraform force-unlock -force $LOCK_INFO || echo "No residual state locks found"
        else
          echo "✅ No residual state locks found"
        fi

    - name: Verify all locks are cleaned up
      if: always()
      run: |
        echo "🔍 Verifying all locks have been cleaned up..."
        
        # 检查 DynamoDB
        LOCK_KEY="$TF_STATE_KEY-md5"
        DYNAMO_LOCK=$(aws dynamodb get-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
          --query 'Item' \
          --output text 2>/dev/null || echo "none")
        
        # 检查 Terraform 状态
        STATE_OUTPUT=$(terraform state pull 2>/dev/null || echo "{}")
        STATE_LOCK=$(echo "$STATE_OUTPUT" | jq -r '.["lock-info"] // empty' || echo "none")
        
        if [ "$DYNAMO_LOCK" = "none" ] && [ -z "$STATE_LOCK" ]; then
          echo "✅ All locks verified as cleaned up"
        else
          echo "⚠️  WARNING: Some locks may still exist"
          echo "DynamoDB lock: $([ "$DYNAMO_LOCK" != "none" ] && echo "exists" || echo "cleaned")"
          echo "State lock: $([ ! -z "$STATE_LOCK" ] && echo "exists" || echo "cleaned")"
        fi
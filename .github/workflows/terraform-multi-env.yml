name: Terraform Multi-Environment Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy

env:
  AWS_REGION: us-east-1
  TF_WORKSPACE: ${{ github.event.inputs.environment }}
  # ä»åç«¯é…ç½®ä¸­è·å–æˆ–è®¾ç½®é»˜è®¤å€¼
  TF_STATE_BUCKET: "terraformstatefile090909"
  TF_STATE_KEY: "env:/${{ github.event.inputs.environment }}/eks-python-cluster/terraform.tfstate"
  DYNAMODB_LOCK_TABLE: "terraform-locks"  # æ ¹æ®å®é™…æƒ…å†µä¿®æ”¹

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Extract DynamoDB table name from backend config
      id: get-dynamodb-table
      run: |
        # ä» backend.tf æˆ– terraform é…ç½®ä¸­æå– DynamoDB è¡¨å
        if [ -f "backend.tf" ]; then
          TABLE_NAME=$(grep -A5 -B5 "dynamodb_table" backend.tf | grep -oP 'dynamodb_table\s*=\s*"\K[^"]+' || echo "$DYNAMODB_LOCK_TABLE")
        else
          TABLE_NAME="$DYNAMODB_LOCK_TABLE"
        fi
        echo "table_name=$TABLE_NAME" >> $GITHUB_OUTPUT
        echo "Using DynamoDB table: $TABLE_NAME"

    - name: Check for existing DynamoDB locks
      id: check-dynamodb-lock
      run: |
        LOCK_KEY="$TF_STATE_KEY-md5"
        echo "Checking for DynamoDB lock with key: $LOCK_KEY"
        
        # æ£€æŸ¥ DynamoDB ä¸­æ˜¯å¦æœ‰é”
        LOCK_EXISTS=$(aws dynamodb get-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
          --query 'Item' \
          --output text 2>/dev/null || echo "false")
        
        if [ "$LOCK_EXISTS" != "false" ] && [ ! -z "$LOCK_EXISTS" ]; then
          echo "lock_exists=true" >> $GITHUB_OUTPUT
          LOCK_INFO=$(aws dynamodb get-item \
            --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
            --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
            --query 'Item' \
            --output json)
          echo "lock_info=$LOCK_INFO" >> $GITHUB_OUTPUT
          echo "âš ï¸  Existing DynamoDB lock detected for key: $LOCK_KEY"
          echo "Lock info: $LOCK_INFO"
        else
          echo "lock_exists=false" >> $GITHUB_OUTPUT
          echo "âœ… No existing DynamoDB locks found"
        fi

    - name: Cleanup stale DynamoDB lock (if exists)
      if: steps.check-dynamodb-lock.outputs.lock_exists == 'true'
      run: |
        LOCK_KEY="$TF_STATE_KEY-md5"
        echo "ğŸ”„ Cleaning up stale DynamoDB lock: $LOCK_KEY"
        
        # åˆ é™¤ DynamoDB ä¸­çš„é”
        aws dynamodb delete-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
          --return-consumed-capacity TOTAL
        
        echo "âœ… DynamoDB lock cleaned up successfully"

    - name: Terraform Init
      run: terraform init -input=false -reconfigure

    - name: Setup Terraform Workspace
      run: |
        terraform workspace select ${{ env.TF_WORKSPACE }} || terraform workspace new ${{ env.TF_WORKSPACE }}
        echo "Current workspace: $(terraform workspace show)"

    - name: Validate tfvars File Exists
      run: |
        if [ ! -f "${{ env.TF_WORKSPACE }}.tfvars" ]; then
          echo "Error: ${{ env.TF_WORKSPACE }}.tfvars file not found!"
          exit 1
        fi
        echo "Using tfvars file: ${{ env.TF_WORKSPACE }}.tfvars"

    - name: Check for existing Terraform state locks
      id: check-state-lock
      run: |
        # æ£€æŸ¥ Terraform çŠ¶æ€ä¸­æ˜¯å¦æœ‰é”
        if terraform state pull 2>/dev/null | grep -q "lock-info"; then
          echo "lock_exists=true" >> $GITHUB_OUTPUT
          LOCK_ID=$(terraform state pull 2>/dev/null | jq -r '.["lock-info"].ID // empty' || echo "")
          echo "lock_id=$LOCK_ID" >> $GITHUB_OUTPUT
          echo "âš ï¸  Existing state lock detected: $LOCK_ID"
        else
          echo "lock_exists=false" >> $GITHUB_OUTPUT
          echo "âœ… No existing state locks found"
        fi

    - name: Cleanup stale Terraform state lock (if exists)
      if: steps.check-state-lock.outputs.lock_exists == 'true'
      run: |
        echo "ğŸ”„ Cleaning up stale Terraform state lock: ${{ steps.check-state-lock.outputs.lock_id }}"
        terraform force-unlock -force ${{ steps.check-state-lock.outputs.lock_id }} || echo "State lock cleanup attempted"

    - name: Terraform Plan
      if: github.event.inputs.action == 'plan'
      run: |
        terraform plan \
          -var-file=${{ env.TF_WORKSPACE }}.tfvars \
          -out=tfplan

    - name: Terraform Apply
      if: github.event.inputs.action == 'apply'
      run: |
        terraform apply \
          -var-file=${{ env.TF_WORKSPACE }}.tfvars \
          -auto-approve

    - name: Terraform Destroy Plan
      if: github.event.inputs.action == 'destroy'
      run: |
        terraform plan -destroy \
          -var-file=${{ env.TF_WORKSPACE }}.tfvars \
          -out=destroy-plan
        echo "Destroy plan generated. Review before proceeding."

    - name: Terraform Destroy
      if: github.event.inputs.action == 'destroy'
      run: |
        terraform destroy \
          -var-file=${{ env.TF_WORKSPACE }}.tfvars \
          -auto-approve
      env:
        TF_CONFIRM_DESTROY: 1

    - name: Update Kubeconfig
      if: github.event.inputs.action == 'apply'
      run: |
        CLUSTER_NAME=$(grep 'cluster_name' ${{ env.TF_WORKSPACE }}.tfvars | awk -F'=' '{print $2}' | tr -d ' "')
        aws eks update-kubeconfig \
          --region ${{ env.AWS_REGION }} \
          --name $CLUSTER_NAME

    - name: Output Cluster Info
      if: github.event.inputs.action == 'apply'
      run: |
        terraform output -json > outputs.json
        echo "=== EKS Cluster Information ==="
        echo "Cluster Endpoint: $(terraform output -raw cluster_endpoint)"
        echo "Cluster Name: $(terraform output -raw cluster_name)"
        echo "Cluster Region: ${{ env.AWS_REGION }}"

    - name: Destroy Completion Message
      if: github.event.inputs.action == 'destroy'
      run: |
        echo "âœ… Terraform destroy completed successfully"
        echo "All resources in environment '${{ env.TF_WORKSPACE }}' have been destroyed"

    - name: Cleanup DynamoDB lock on completion
      if: always()
      run: |
        echo "ğŸ§¹ Final DynamoDB lock cleanup..."
        LOCK_KEY="$TF_STATE_KEY-md5"
        
        # æ£€æŸ¥å¹¶æ¸…ç† DynamoDB é”
        LOCK_EXISTS=$(aws dynamodb get-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
          --query 'Item' \
          --output text 2>/dev/null || echo "false")
        
        if [ "$LOCK_EXISTS" != "false" ] && [ ! -z "$LOCK_EXISTS" ]; then
          echo "Removing residual DynamoDB lock: $LOCK_KEY"
          aws dynamodb delete-item \
            --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
            --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}"
          echo "âœ… Residual DynamoDB lock cleaned up"
        else
          echo "âœ… No residual DynamoDB locks found"
        fi

    - name: Cleanup Terraform state lock on completion
      if: always()
      run: |
        echo "ğŸ§¹ Final Terraform state lock cleanup..."
        # å°è¯•æ¸…ç†ä»»ä½•å¯èƒ½æ®‹ç•™çš„çŠ¶æ€é”
        LOCK_INFO=$(terraform state pull 2>/dev/null | jq -r '.["lock-info"].ID // empty' || echo "")
        if [ ! -z "$LOCK_INFO" ]; then
          echo "Removing residual state lock: $LOCK_INFO"
          terraform force-unlock -force $LOCK_INFO || echo "No residual state locks found"
        else
          echo "âœ… No residual state locks found"
        fi

    - name: Verify all locks are cleaned up
      if: always()
      run: |
        echo "ğŸ” Verifying all locks have been cleaned up..."
        
        # æ£€æŸ¥ DynamoDB
        LOCK_KEY="$TF_STATE_KEY-md5"
        DYNAMO_LOCK=$(aws dynamodb get-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_KEY\"}}" \
          --query 'Item' \
          --output text 2>/dev/null || echo "none")
        
        # æ£€æŸ¥ Terraform çŠ¶æ€
        STATE_LOCK=$(terraform state pull 2>/dev/null | jq -r '.["lock-info"] // empty' || echo "none")
        
        if [ "$DYNAMO_LOCK" = "none" ] && [ -z "$STATE_LOCK" ]; then
          echo "âœ… All locks verified as cleaned up"
        else
          echo "âš ï¸  WARNING: Some locks may still exist"
          echo "DynamoDB lock: $([ "$DYNAMO_LOCK" != "none" ] && echo "exists" || echo "cleaned")"
          echo "State lock: $([ ! -z "$STATE_LOCK" ] && echo "exists" || echo "cleaned")"
          # ä¸é€€å‡ºå¤±è´¥ï¼Œåªæ˜¯è­¦å‘Š
        fi
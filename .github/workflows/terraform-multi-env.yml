name: Terraform Multi-Environment Deployment

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      action:
        description: 'Terraform action to perform'
        required: true
        default: 'plan'
        type: choice
        options:
        - plan
        - apply
        - destroy

env:
  AWS_REGION: us-east-1
  TF_STATE_BUCKET: "terraformstatefile090909"
  TF_STATE_KEY_PREFIX: "env"
  DYNAMODB_LOCK_TABLE: "terraform-locks"

# 添加并发控制，防止同一环境同时部署
concurrency:
  group: ${{ github.workflow }}-${{ github.event.inputs.environment }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Setup Terraform without workspace interference
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: "1.5.0"
        terraform_wrapper: false

    - name: Set environment variables
      id: set-env
      run: |
        ENVIRONMENT="${{ github.event.inputs.environment }}"
        TF_STATE_KEY="$TF_STATE_KEY_PREFIX:/$ENVIRONMENT/eks-python-cluster/terraform.tfstate"
        echo "ENVIRONMENT=$ENVIRONMENT" >> $GITHUB_ENV
        echo "TF_STATE_KEY=$TF_STATE_KEY" >> $GITHUB_ENV
        echo "Using environment: $ENVIRONMENT"
        echo "State key: $TF_STATE_KEY"

    - name: Extract DynamoDB table name from backend config
      id: get-dynamodb-table
      run: |
        if [ -f "backend.tf" ]; then
          TABLE_NAME=$(grep "dynamodb_table" backend.tf | grep -oP 'dynamodb_table\s*=\s*"\K[^"]+' || echo "$DYNAMODB_LOCK_TABLE")
        else
          TABLE_NAME="$DYNAMODB_LOCK_TABLE"
        fi
        echo "table_name=${TABLE_NAME}" >> $GITHUB_OUTPUT
        echo "Using DynamoDB table: $TABLE_NAME"

    - name: Check for stale DynamoDB locks
      id: check-dynamodb-lock
      run: |
        # 正确的 DynamoDB 锁 ID 格式：bucket/path-to-state-file-md5
        LOCK_ID="$TF_STATE_BUCKET/$TF_STATE_KEY-md5"
        echo "Checking for DynamoDB lock with ID: $LOCK_ID"
        
        # 获取锁信息
        LOCK_INFO=$(aws dynamodb get-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}" \
          --output json 2>/dev/null || echo "{}")
        
        # 检查锁是否存在且是否过期（超过15分钟）
        if echo "$LOCK_INFO" | jq -e '.Item' > /dev/null 2>&1; then
          LOCK_TIME=$(echo "$LOCK_INFO" | jq -r '.Item.Info.S // empty' | jq -r '.Created // empty' 2>/dev/null | head -1 || echo "")
          if [ ! -z "$LOCK_TIME" ]; then
            # 转换时间格式并计算锁年龄
            LOCK_EPOCH=$(date -d "$(echo "$LOCK_TIME" | sed 's/\.[0-9]*//')" +%s 2>/dev/null || echo 0)
            CURRENT_EPOCH=$(date +%s)
            LOCK_AGE=$((CURRENT_EPOCH - LOCK_EPOCH))
            
            if [ $LOCK_AGE -gt 900 ]; then # 15分钟
              echo "lock_exists=true" >> $GITHUB_OUTPUT
              echo "lock_id=$LOCK_ID" >> $GITHUB_OUTPUT
              echo "lock_age=$LOCK_AGE" >> $GITHUB_OUTPUT
              echo "⚠️  Stale DynamoDB lock detected (age: ${LOCK_AGE}s): $LOCK_ID"
            else
              echo "lock_exists=false" >> $GITHUB_OUTPUT
              echo "✅ Active lock found (not stale), age: ${LOCK_AGE}s"
            fi
          else
            echo "lock_exists=true" >> $GITHUB_OUTPUT
            echo "lock_id=$LOCK_ID" >> $GITHUB_OUTPUT
            echo "⚠️  DynamoDB lock with invalid timestamp: $LOCK_ID"
          fi
        else
          echo "lock_exists=false" >> $GITHUB_OUTPUT
          echo "✅ No DynamoDB locks found"
        fi

    - name: Cleanup stale DynamoDB lock (if exists)
      if: steps.check-dynamodb-lock.outputs.lock_exists == 'true'
      run: |
        LOCK_ID="${{ steps.check-dynamodb-lock.outputs.lock_id }}"
        echo "🔄 Cleaning up stale DynamoDB lock: $LOCK_ID (age: ${{ steps.check-dynamodb-lock.outputs.lock_age }}s)"
        
        aws dynamodb delete-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}"
        
        echo "✅ DynamoDB lock cleaned up successfully"

    - name: Terraform Init with explicit backend config
      run: |
        terraform init -input=false -reconfigure \
          -backend-config="bucket=$TF_STATE_BUCKET" \
          -backend-config="key=$TF_STATE_KEY" \
          -backend-config="dynamodb_table=${{ steps.get-dynamodb-table.outputs.table_name }}" \
          -backend-config="region=$AWS_REGION"

    - name: Manage Terraform workspace without TF_WORKSPACE env
      id: workspace-setup
      run: |
        # 首先取消任何可能存在的 TF_WORKSPACE 环境变量
        unset TF_WORKSPACE
        
        # 列出所有工作区
        echo "Available workspaces:"
        terraform workspace list
        
        # 检查目标工作区是否已存在
        if terraform workspace list | grep -q " $ENVIRONMENT$"; then
          echo "Workspace '$ENVIRONMENT' already exists, selecting it..."
          terraform workspace select $ENVIRONMENT
          echo "workspace_action=selected" >> $GITHUB_OUTPUT
        else
          echo "Creating new workspace: $ENVIRONMENT"
          terraform workspace new $ENVIRONMENT
          echo "workspace_action=created" >> $GITHUB_OUTPUT
        fi
        
        echo "Current workspace: $(terraform workspace show)"

    - name: Validate tfvars File Exists
      run: |
        if [ ! -f "$ENVIRONMENT.tfvars" ]; then
          echo "Error: $ENVIRONMENT.tfvars file not found!"
          exit 1
        fi
        echo "Using tfvars file: $ENVIRONMENT.tfvars"

    - name: Check for existing Terraform state locks
      id: check-state-lock
      run: |
        # 取消 TF_WORKSPACE 环境变量以避免干扰
        unset TF_WORKSPACE
        
        STATE_OUTPUT=$(terraform state pull 2>/dev/null || echo "{}")
        if echo "$STATE_OUTPUT" | grep -q "lock-info"; then
          echo "lock_exists=true" >> $GITHUB_OUTPUT
          LOCK_ID=$(echo "$STATE_OUTPUT" | jq -r '.["lock-info"].ID // empty' || echo "")
          echo "lock_id=$LOCK_ID" >> $GITHUB_OUTPUT
          echo "⚠️  Existing state lock detected: $LOCK_ID"
        else
          echo "lock_exists=false" >> $GITHUB_OUTPUT
          echo "✅ No existing state locks found"
        fi

    - name: Cleanup stale Terraform state lock (if exists)
      if: steps.check-state-lock.outputs.lock_exists == 'true'
      run: |
        unset TF_WORKSPACE
        echo "🔄 Cleaning up stale Terraform state lock: ${{ steps.check-state-lock.outputs.lock_id }}"
        terraform force-unlock -force ${{ steps.check-state-lock.outputs.lock_id }} || echo "State lock cleanup attempted"

    - name: Terraform Plan with lock timeout
      if: github.event.inputs.action == 'plan'
      run: |
        unset TF_WORKSPACE
        terraform plan \
          -var-file=$ENVIRONMENT.tfvars \
          -out=tfplan \
          -lock-timeout=5m

    - name: Terraform Apply with lock timeout
      if: github.event.inputs.action == 'apply'
      run: |
        unset TF_WORKSPACE
        terraform apply \
          -var-file=$ENVIRONMENT.tfvars \
          -auto-approve \
          -lock-timeout=10m

    - name: Terraform Destroy Plan with lock timeout
      if: github.event.inputs.action == 'destroy'
      run: |
        unset TF_WORKSPACE
        terraform plan -destroy \
          -var-file=$ENVIRONMENT.tfvars \
          -out=destroy-plan \
          -lock-timeout=5m
        echo "Destroy plan generated. Review before proceeding."

    - name: Terraform Destroy with lock timeout
      if: github.event.inputs.action == 'destroy'
      run: |
        unset TF_WORKSPACE
        terraform destroy \
          -var-file=$ENVIRONMENT.tfvars \
          -auto-approve \
          -lock-timeout=10m
      env:
        TF_CONFIRM_DESTROY: 1

    - name: Update Kubeconfig
      if: github.event.inputs.action == 'apply'
      run: |
        CLUSTER_NAME=$(grep 'cluster_name' $ENVIRONMENT.tfvars | awk -F'=' '{print $2}' | tr -d ' "')
        aws eks update-kubeconfig \
          --region $AWS_REGION \
          --name $CLUSTER_NAME

    - name: Output Cluster Info
      if: github.event.inputs.action == 'apply'
      run: |
        unset TF_WORKSPACE
        terraform output -json > outputs.json
        echo "=== EKS Cluster Information ==="
        echo "Cluster Endpoint: $(terraform output -raw cluster_endpoint)"
        echo "Cluster Name: $(terraform output -raw cluster_name)"
        echo "Cluster Region: $AWS_REGION"

    - name: Destroy Completion Message
      if: github.event.inputs.action == 'destroy'
      run: |
        echo "✅ Terraform destroy completed successfully"
        echo "All resources in environment '$ENVIRONMENT' have been destroyed"

    - name: Cleanup DynamoDB lock on completion
      if: always()
      run: |
        echo "🧹 Final DynamoDB lock cleanup..."
        # 使用正确的锁ID格式
        LOCK_ID="$TF_STATE_BUCKET/$TF_STATE_KEY-md5"
        
        LOCK_EXISTS=$(aws dynamodb get-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}" \
          --query 'Item' \
          --output text 2>/dev/null || echo "false")
        
        if [ "$LOCK_EXISTS" != "false" ] && [ ! -z "$LOCK_EXISTS" ]; then
          echo "Removing residual DynamoDB lock: $LOCK_ID"
          aws dynamodb delete-item \
            --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
            --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}"
          echo "✅ Residual DynamoDB lock cleaned up"
        else
          echo "✅ No residual DynamoDB locks found"
        fi

    - name: Cleanup Terraform state lock on completion
      if: always()
      run: |
        echo "🧹 Final Terraform state lock cleanup..."
        unset TF_WORKSPACE
        STATE_OUTPUT=$(terraform state pull 2>/dev/null || echo "{}")
        LOCK_INFO=$(echo "$STATE_OUTPUT" | jq -r '.["lock-info"].ID // empty' || echo "")
        if [ ! -z "$LOCK_INFO" ]; then
          echo "Removing residual state lock: $LOCK_INFO"
          terraform force-unlock -force $LOCK_INFO || echo "No residual state locks found"
        else
          echo "✅ No residual state locks found"
        fi

    - name: Verify all locks are cleaned up
      if: always()
      run: |
        echo "🔍 Verifying all locks have been cleaned up..."
        
        # 使用正确的锁ID格式
        LOCK_ID="$TF_STATE_BUCKET/$TF_STATE_KEY-md5"
        DYNAMO_LOCK=$(aws dynamodb get-item \
          --table-name ${{ steps.get-dynamodb-table.outputs.table_name }} \
          --key "{\"LockID\": {\"S\": \"$LOCK_ID\"}}" \
          --query 'Item' \
          --output text 2>/dev/null || echo "none")
        
        unset TF_WORKSPACE
        STATE_OUTPUT=$(terraform state pull 2>/dev/null || echo "{}")
        STATE_LOCK=$(echo "$STATE_OUTPUT" | jq -r '.["lock-info"] // empty' || echo "none")
        
        if [ "$DYNAMO_LOCK" = "none" ] && [ -z "$STATE_LOCK" ]; then
          echo "✅ All locks verified as cleaned up"
        else
          echo "⚠️  WARNING: Some locks may still exist"
          echo "DynamoDB lock: $([ "$DYNAMO_LOCK" != "none" ] && echo "exists" || echo "cleaned")"
          echo "State lock: $([ ! -z "$STATE_LOCK" ] && echo "exists" || echo "cleaned")"
        fi